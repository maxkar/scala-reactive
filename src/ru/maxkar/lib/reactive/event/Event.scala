package ru.maxkar.lib.reactive.event

import ru.maxkar.lib.reactive.wave.Participant

/**
 * Event source trait. Each event source have a
 * specific type of "events". These events can be accessed
 * at any moment, but you can get meaningful values only
 * during the wave propagation, after this event was
 * resolved and wave was is not complete yet.
 * @param T event type.
 */
trait Event[T] {
  /**
   * Returns value of this node. This can be set to
   * some "neutral" value when this node does not
   * participate in the flow.
   * @param event generated by this node during a current wave.
   */
  def value() : T



  /**
   * Adds a "correlated" node. That node will be added to the
   * flow each time this source node parcitipates in that flow.
   */
  def addCorrelatedNode(node : Participant) : Unit



  /**
   * Removes previously added correlated node. If node was added
   * multiple times, decreases number of correlations by one.
   */
  def removeCorrelatedNode(node : Participant) : Unit



  /**
   * Defers evaluation of target node until this event node
   * is completely resolved (i.e. all events are generated)
   * during current wave.
   * @param target target to defer. This node should be engaged in the wave.
   */
  def defer(target : Participant) : Unit



  /**
   * Defers evaluation of function and note until this event
   * node is completely resolved (i.e. all events are generated)
   * during current wave. After the resolution, provided callback
   * is invoked first. That callback may further defer participant
   * in question.
   * @param target target to defer. This node should be engaged in the wave.
   * @param callback callback to invoke after this event is resolved. That
   * callback can defer <code>target</code> even more.
   */
  def deferBy(target : Participant, callback : () â‡’ Unit) : Unit
}



/**
 * Event access point.
 */
object Event {
  /** Creates a new "trigger" event. */
  def trigger() : Trigger = new Trigger()
}
